<!--
WebP Converter with AI-Powered SEO Filenames
This application converts various image formats (PNG, JPG, etc.) to WebP format
and uses the Gemini API to generate an SEO-friendly filename based on the image content.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebP Converter</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the purple gradient background and Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f0f4f8 0%, #e0e8f0 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* Style for the dashed drop zone border and purple accent */
        .drop-zone {
            border: 2px dashed #9333ea; /* Purple color */
            transition: all 0.3s ease;
        }
        .drop-zone.dragover {
            background-color: #f3e8ff; /* Light purple background on drag over */
            border-color: #7e22ce;
        }
        /* Custom purple gradient for the button */
        .purple-gradient-btn {
            background-image: linear-gradient(to right, #9333ea 0%, #7e22ce 100%);
            transition: all 0.3s ease;
        }
        .purple-gradient-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        /* Hide the hidden canvas but keep it in the DOM for conversion */
        #conversion-canvas {
            position: absolute;
            left: -9999px;
            top: -9999px;
        }
    </style>
</head>
<body class="p-4">

    <div id="app" class="w-full max-w-2xl mx-auto text-center p-6 sm:p-10 bg-white shadow-2xl rounded-xl">

        <!-- Header -->
        <div class="mb-8">
            <div class="mx-auto w-12 h-12 bg-purple-100 rounded-xl flex items-center justify-center mb-4">
                <!-- Icon: Gallery/Image Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-purple-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 18m-4-10h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
            </div>
            <h1 class="text-4xl font-extrabold text-gray-800 mb-2">WebP Converter</h1>
            <p class="text-gray-500">Transform your images to WebP format instantly with AI-powered SEO filenames.</p>
        </div>

        <!-- Conversion Area / Drop Zone -->
        <div id="drop-zone" class="drop-zone p-8 rounded-xl bg-white shadow-lg flex flex-col items-center justify-center transition-shadow">

            <!-- Hidden file input for selection -->
            <input type="file" id="file-input" accept="image/*" class="hidden">

            <!-- Initial State -->
            <div id="initial-state" class="w-full">
                <div class="mx-auto w-16 h-16 bg-purple-50 rounded-full flex items-center justify-center mb-4">
                    <!-- Upload Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-purple-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                    </svg>
                </div>
                <p class="text-lg font-semibold text-gray-700 mb-2">Drop your image here</p>
                <p class="text-gray-500 mb-6">or click to browse from your device</p>

                <button id="select-image-btn" class="purple-gradient-btn text-white font-bold py-3 px-8 rounded-full shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-purple-300">
                    Select Image
                </button>
                <p class="text-sm text-gray-400 mt-4">Supports JPG, PNG, GIF, BMP, and more</p>
            </div>

            <!-- Conversion Status & Loading State -->
            <div id="processing-state" class="hidden w-full p-4">
                <div id="loading-spinner" class="animate-spin h-10 w-10 border-4 border-purple-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                <p id="status-text" class="text-lg font-semibold text-purple-600">Processing image and generating SEO filename...</p>
            </div>

            <!-- Result State -->
            <div id="result-state" class="hidden w-full p-4">
                <img id="preview-image" src="" alt="Converted Image Preview" class="max-h-64 object-contain rounded-lg mx-auto mb-4 shadow-md max-w-full h-auto">
                <p class="text-lg font-semibold text-green-600 mb-2">Conversion Complete!</p>
                <p class="text-gray-600 mb-4">New SEO-Friendly Filename (AI Generated):</p>
                <code id="new-filename-display" class="bg-gray-100 text-gray-800 p-2 rounded-lg font-mono text-sm inline-block mb-6 break-all"></code>

                <button id="download-btn" class="purple-gradient-btn text-white font-bold py-3 px-8 rounded-full shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-purple-300">
                    Download WebP
                </button>
                <button id="reset-btn" class="text-gray-600 bg-white border border-gray-300 font-bold py-3 px-8 rounded-full ml-4 hover:bg-gray-50 focus:outline-none">
                    Convert Another
                </button>
            </div>

        </div>

        <!-- Footer Note -->
        <p class="text-xs text-gray-400 mt-6">
            All processing happens in your browser. Your images never leave your device.
        </p>
        <p class="text-xs text-gray-400 mt-2">
            AI renaming uses the Gemini API.
        </p>

    </div>

    <!-- Hidden Canvas for client-side image processing (REQUIRED for toBlob/WebP conversion) -->
    <canvas id="conversion-canvas"></canvas>


<script type="module">
    // Global API key for Gemini models (provided by environment)
    const apiKey = "AIzaSyChsJtQKCt8pJUCTjIe_-e0t777uWzXY7A"; 
    // API endpoint for multimodal generation (image understanding + text output)
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

    // --- DOM Elements ---
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const selectImageBtn = document.getElementById('select-image-btn');
    const downloadBtn = document.getElementById('download-btn');
    const resetBtn = document.getElementById('reset-btn');
    const canvas = document.getElementById('conversion-canvas');
    const ctx = canvas.getContext('2d');

    const initialState = document.getElementById('initial-state');
    const processingState = document.getElementById('processing-state');
    const resultState = document.getElementById('result-state');
    const statusText = document.getElementById('status-text');
    const newFilenameDisplay = document.getElementById('new-filename-display');
    const previewImage = document.getElementById('preview-image');

    let convertedBlob = null;
    let newFilename = 'converted-image.webp';


    // --- Utility Functions ---

    /**
     * Converts a File object or Blob into a Base64 string for API submission.
     * @param {Blob | File} blob - The image blob/file.
     * @returns {Promise<string>} Base64 data string.
     */
    function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                // Remove the data URL prefix (e.g., "data:image/png;base64,")
                const base64Data = reader.result.split(',')[1];
                resolve(base64Data);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }

    /**
     * Exponential Backoff Retry mechanism for fetch.
     * @param {Function} apiCall - The function that returns the fetch Promise.
     * @param {number} maxRetries - Maximum number of retries.
     * @returns {Promise<Response>} The final successful Response object.
     */
    async function fetchWithRetry(apiCall, maxRetries = 5) {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await apiCall();
                if (response.ok) {
                    return response;
                }
                // Handle rate limiting or server errors, only retry on 429 or 5xx
                if (response.status === 429 || response.status >= 500) {
                    console.warn(`Attempt ${attempt} failed with status ${response.status}. Retrying...`);
                } else {
                    // Non-retryable error
                    throw new Error(`API call failed with status ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error(`Attempt ${attempt} failed with network error:`, error);
                // Non-retryable error if not a network issue
                if (attempt === maxRetries) {
                     throw error;
                }
            }

            // Exponential backoff wait: 2^attempt * 200ms
            const delay = Math.pow(2, attempt) * 200;
            await new Promise(resolve => setTimeout(resolve, delay));
        }
        throw new Error('API call failed after maximum retries.');
    }


    // --- Core Logic ---

    /**
     * Calls Gemini API to generate an SEO-friendly filename.
     * @param {string} base64Image - Base64 data of the image.
     * @param {string} mimeType - MIME type of the image.
     * @returns {Promise<string>} SEO-friendly filename (e.g., "beautiful-sunset.webp").
     */
    async function generateSeoFilename(base64Image, mimeType) {
        // System prompt is highly specific to ensure clean output
        const systemPrompt = "You are a specialist in search engine optimization. Your task is to analyze the image and generate the best filename for it. The filename must be: 1. All lowercase. 2. Hyphen-separated. 3. Concise (2 to 5 descriptive words). 4. Must end with the file extension '.webp'. Output ONLY the filename, nothing else.";
        const userQuery = "Generate the SEO filename for this image.";

        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [
                        { text: userQuery },
                        {
                            inlineData: {
                                mimeType: mimeType,
                                data: base64Image
                            }
                        }
                    ]
                }
            ],
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            }
        };

        const apiCall = () => fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        try {
            const response = await fetchWithRetry(apiCall);
            const result = await response.json();
            
            const generatedText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (generatedText) {
                // Clean and normalize the output from the model
                let cleanedName = generatedText.trim().toLowerCase();
                // Remove any surrounding quotes or backticks if the model added them
                cleanedName = cleanedName.replace(/^['"`]|['"`]$/g, '');
                // Replace any non-alphanumeric/non-dot characters (excluding hyphens) with hyphens
                cleanedName = cleanedName.replace(/[^a-z0-9.]+/g, '-');
                // Ensure it ends with .webp, remove it first if it exists, then append
                cleanedName = cleanedName.replace(/\.webp$/, '');
                cleanedName = cleanedName.replace(/^-|-$/g, ' '); // Remove leading/trailing hyphens before cleaning up spaces
                cleanedName = cleanedName.trim().replace(/\s+/g, '-');
                
                return cleanedName.length > 0 ? `${cleanedName}.webp` : 'ai-generated-image.webp';
            }
        } catch (error) {
            console.error('Error generating filename with AI:', error);
        }
        // Fallback filename if AI fails
        return 'converted-image-fallback.webp';
    }


    /**
     * Converts a File object to a WebP Blob and generates an SEO filename.
     * @param {File} file - The image file to process.
     */
    async function processFile(file) {
        // 1. Setup UI for processing
        initialState.classList.add('hidden');
        resultState.classList.add('hidden');
        processingState.classList.remove('hidden');
        statusText.textContent = '1/3: Loading image data...';

        try {
            const img = new Image();
            const url = URL.createObjectURL(file);

            // Wait for image to load
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = () => reject(new Error("Image failed to load. The file might be corrupted or unsupported."));
                img.src = url;
            });

            // 2. Convert to WebP (Client-Side)
            statusText.textContent = '2/3: Converting image to WebP format...';
            
            // Set canvas size to image size
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            
            // Draw the image onto the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);

            // Get the WebP blob from the canvas (quality 0.92 is a good default for balance)
            convertedBlob = await new Promise(resolve => {
                // Use a standard canvas for maximum compatibility in this environment
                canvas.toBlob(resolve, 'image/webp', 0.92);
            });

            if (!convertedBlob) {
                throw new Error("Failed to convert image to WebP blob. Check browser support for toBlob('image/webp').");
            }

            // Set the preview image URL from the blob (for display)
            previewImage.src = URL.createObjectURL(convertedBlob);
            
            // 3. Generate SEO Filename (AI-Powered)
            statusText.textContent = '3/3: Generating AI-powered SEO filename...';

            // Get the base64 of the original file for multimodal analysis
            const base64Image = await blobToBase64(file);
            newFilename = await generateSeoFilename(base64Image, file.type);
            
            newFilenameDisplay.textContent = newFilename;

            // 4. Update UI for Result
            processingState.classList.add('hidden');
            resultState.classList.remove('hidden');

            // Clean up the object URL
            URL.revokeObjectURL(url);

        } catch (error) {
            console.error('Conversion failed:', error);
            // Show a custom message box instead of alert()
            showError(`Conversion Error: ${error.message}`);
            resetApp();
        }
    }


    // --- Event Handlers & Initialization ---

    function handleFileSelection(files) {
        if (files && files.length > 0 && files[0].type.startsWith('image/')) {
            processFile(files[0]);
        } else if (files && files.length > 0) {
            showError("Invalid file type. Please select a supported image file (JPG, PNG, GIF, BMP).");
        }
    }

    // Custom Error Message Box (since alert() is forbidden)
    function showError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        errorDiv.innerHTML = `
            <div class="bg-white p-6 rounded-lg shadow-2xl max-w-sm mx-4 text-center">
                <p class="text-xl font-bold text-red-600 mb-4">Conversion Failed</p>
                <p class="text-gray-700 mb-6">${message}</p>
                <button id="close-error-btn" class="purple-gradient-btn text-white font-bold py-2 px-6 rounded-full">
                    Close
                </button>
            </div>
        `;
        document.body.appendChild(errorDiv);

        document.getElementById('close-error-btn').onclick = () => {
            document.body.removeChild(errorDiv);
        };
    }

    // Drag and Drop Listeners
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        // Only allow dragover effect if not already processing
        if (processingState.classList.contains('hidden')) {
            dropZone.classList.add('dragover');
        }
    });

    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        if (processingState.classList.contains('hidden')) { // Only process if not currently processing
            handleFileSelection(e.dataTransfer.files);
        }
    });

    // File Input and Button Listeners
    selectImageBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => handleFileSelection(e.target.files));

    // Download Listener
    downloadBtn.addEventListener('click', () => {
        if (convertedBlob && newFilename) {
            // Create a temporary link element
            const a = document.createElement('a');
            a.href = URL.createObjectURL(convertedBlob);
            a.download = newFilename; // Use the AI-generated filename
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            // Clean up the object URL after triggering download
            URL.revokeObjectURL(a.href);
        } else {
            showError("No converted image found for download.");
        }
    });

    // Reset Listener
    function resetApp() {
        // Clear previous data
        convertedBlob = null;
        newFilename = 'converted-image.webp';
        fileInput.value = ''; // Reset file input
        previewImage.src = '';

        // Reset UI state
        processingState.classList.add('hidden');
        resultState.classList.add('hidden');
        initialState.classList.remove('hidden');
        dropZone.classList.remove('dragover');
    }
    resetBtn.addEventListener('click', resetApp);

    // Initial setup
    resetApp();
</script>
</body>
</html>
