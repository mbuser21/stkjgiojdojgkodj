<!--
WebP Converter with AI-Powered SEO Filenames
This application converts various image formats (PNG, JPG, etc.) to WebP format
and uses the Gemini API to generate an SEO-friendly filename based on the image content.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebP Converter</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the purple gradient background and Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f0f4f8 0%, #e0e8f0 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* Style for the dashed drop zone border and purple accent */
        .drop-zone {
            border: 2px dashed #9333ea; /* Purple color */
            transition: all 0.3s ease;
        }
        .drop-zone.dragover {
            background-color: #f3e8ff; /* Light purple background on drag over */
            border-color: #7e22ce;
        }
        /* Custom purple gradient for the button */
        .purple-gradient-btn {
            background-image: linear-gradient(to right, #9333ea 0%, #7e22ce 100%);
            transition: all 0.3s ease;
        }
        .purple-gradient-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        /* Hide the hidden canvas but keep it in the DOM for conversion */
        #conversion-canvas {
            position: absolute;
            left: -9999px;
            top: -9999px;
        }
    </style>
</head>
<body class="p-4">

    <div id="app" class="w-full max-w-2xl mx-auto text-center p-6 sm:p-10 bg-white shadow-2xl rounded-xl">

        <!-- Header -->
        <div class="mb-8">
            <div class="mx-auto w-12 h-12 bg-purple-100 rounded-xl flex items-center justify-center mb-4">
                <!-- Icon: Gallery/Image Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-purple-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 18m-4-10h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
            </div>
            <h1 class="text-4xl font-extrabold text-gray-800 mb-2">WebP Converter (Batch Ready)</h1>
            <p class="text-gray-500">Transform multiple images to WebP format instantly with AI-powered SEO filenames.</p>
        </div>

        <!-- Conversion Area / Drop Zone -->
        <div id="drop-zone" class="drop-zone p-8 rounded-xl bg-white shadow-lg flex flex-col items-center justify-center transition-shadow">

            <!-- Hidden file input for selection - ADDED 'multiple' -->
            <input type="file" id="file-input" accept="image/*" class="hidden" multiple>

            <!-- Initial State -->
            <div id="initial-state" class="w-full">
                <div class="mx-auto w-16 h-16 bg-purple-50 rounded-full flex items-center justify-center mb-4">
                    <!-- Upload Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-purple-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                    </svg>
                </div>
                <p class="text-lg font-semibold text-gray-700 mb-2">Drop your images here</p>
                <p class="text-gray-500 mb-6">or click to browse for a batch of files</p>

                <button id="select-image-btn" class="purple-gradient-btn text-white font-bold py-3 px-8 rounded-full shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-purple-300">
                    Select Images
                </button>
                <p class="text-sm text-gray-400 mt-4">Supports JPG, PNG, GIF, BMP, and more</p>
            </div>

            <!-- Conversion Status & Loading State -->
            <div id="processing-state" class="hidden w-full p-4">
                <div id="loading-spinner" class="animate-spin h-10 w-10 border-4 border-purple-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                <!-- Status text will dynamically update with the current file number -->
                <p id="status-text" class="text-lg font-semibold text-purple-600">Processing files...</p>
            </div>

            <!-- Result State - MODIFIED for list view -->
            <div id="result-state" class="hidden w-full p-4">
                <p class="text-lg font-semibold text-green-600 mb-2">Conversion Complete!</p>
                <p class="text-gray-600 mb-4">Successfully converted <span id="count-display" class="font-bold text-purple-600">0</span> images:</p>
                
                <!-- Container for the list of converted files -->
                <div id="results-list" class="space-y-4 max-h-80 overflow-y-auto p-4 bg-gray-50 border border-gray-200 rounded-lg mb-6 text-left">
                    <!-- Results rendered here by JS -->
                </div>
                
                <!-- Download button updated to download all -->
                <button id="download-btn" class="purple-gradient-btn text-white font-bold py-3 px-8 rounded-full shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-purple-300">
                    Download All (.webp)
                </button>
                <button id="reset-btn" class="text-gray-600 bg-white border border-gray-300 font-bold py-3 px-8 rounded-full ml-4 hover:bg-gray-50 focus:outline-none">
                    Convert Another Batch
                </button>
            </div>

        </div>

        <!-- Footer Note -->
        <p class="text-xs text-gray-400 mt-6">
            All processing happens in your browser. Your images never leave your device.
        </p>
        <p class="text-xs text-gray-400 mt-2">
            AI renaming uses the Gemini API.
        </p>

    </div>

    <!-- Hidden Canvas for client-side image processing (REQUIRED for toBlob/WebP conversion) -->
    <canvas id="conversion-canvas"></canvas>


<script type="module">
    // Global API key for Gemini models (provided by environment)
    const apiKey = "AIzaSyChsJtQKCt8pJUCTjIe_-e0t777uWzXY7A"; 
    // API endpoint for multimodal generation (image understanding + text output)
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

    // --- DOM Elements ---
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const selectImageBtn = document.getElementById('select-image-btn');
    const downloadBtn = document.getElementById('download-btn');
    const resetBtn = document.getElementById('reset-btn');
    const canvas = document.getElementById('conversion-canvas');
    const ctx = canvas.getContext('2d');

    const initialState = document.getElementById('initial-state');
    const processingState = document.getElementById('processing-state');
    const resultState = document.getElementById('result-state');
    const statusText = document.getElementById('status-text');
    
    // NEW DOM elements for batch processing
    const resultsList = document.getElementById('results-list');
    const countDisplay = document.getElementById('count-display');

    // Replaced single file state with an array of results
    let conversionResults = []; // [{ blob: Blob, filename: string, originalName: string }]


    // --- Utility Functions ---

    /**
     * Converts a File object or Blob into a Base64 string for API submission.
     * @param {Blob | File} blob - The image blob/file.
     * @returns {Promise<string>} Base64 data string.
     */
    function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                // Remove the data URL prefix (e.g., "data:image/png;base64,")
                const base64Data = reader.result.split(',')[1];
                resolve(base64Data);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }

    /**
     * Exponential Backoff Retry mechanism for fetch.
     * @param {Function} apiCall - The function that returns the fetch Promise.
     * @param {number} maxRetries - Maximum number of retries.
     * @returns {Promise<Response>} The final successful Response object.
     */
    async function fetchWithRetry(apiCall, maxRetries = 5) {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await apiCall();
                if (response.ok) {
                    return response;
                }
                // Handle rate limiting or server errors, only retry on 429 or 5xx
                if (response.status === 429 || response.status >= 500) {
                    console.warn(`Attempt ${attempt} failed with status ${response.status}. Retrying...`);
                } else {
                    // Non-retryable error
                    throw new Error(`API call failed with status ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error(`Attempt ${attempt} failed with network error:`, error);
                // Non-retryable error if not a network issue
                if (attempt === maxRetries) {
                     throw error;
                }
            }

            // Exponential backoff wait: 2^attempt * 200ms
            const delay = Math.pow(2, attempt) * 200;
            await new Promise(resolve => setTimeout(resolve, delay));
        }
        throw new Error('API call failed after maximum retries.');
    }


    // --- Core Logic ---

    /**
     * Calls Gemini API to generate an SEO-friendly filename.
     * @param {string} base64Image - Base64 data of the image.
     * @param {string} mimeType - MIME type of the image.
     * @returns {Promise<string>} SEO-friendly filename (e.g., "beautiful-sunset.webp").
     */
    async function generateSeoFilename(base64Image, mimeType) {
        // System prompt is highly specific to ensure clean output
        const systemPrompt = "You are a specialist in search engine optimization. Your task is to analyze the image and generate the best filename for it. The filename must be: 1. All lowercase. 2. Hyphen-separated. 3. Concise (2 to 5 descriptive words). 4. Must end with the file extension '.webp'. Output ONLY the filename, nothing else.";
        const userQuery = "Generate the SEO filename for this image.";

        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [
                        { text: userQuery },
                        {
                            inlineData: {
                                mimeType: mimeType,
                                data: base64Image
                            }
                        }
                    ]
                }
            ],
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            }
        };

        const apiCall = () => fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        try {
            const response = await fetchWithRetry(apiCall);
            const result = await response.json();
            
            const generatedText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (generatedText) {
                // Clean and normalize the output from the model
                let cleanedName = generatedText.trim().toLowerCase();
                // Remove any surrounding quotes or backticks if the model added them
                cleanedName = cleanedName.replace(/^['"`]|['"`]$/g, '');
                // Replace any non-alphanumeric/non-dot characters (excluding hyphens) with hyphens
                cleanedName = cleanedName.replace(/[^a-z0-9.]+/g, '-');
                // Ensure it ends with .webp, remove it first if it exists, then append
                cleanedName = cleanedName.replace(/\.webp$/, '');
                cleanedName = cleanedName.replace(/^-|-$/g, ' '); // Remove leading/trailing hyphens before cleaning up spaces
                cleanedName = cleanedName.trim().replace(/\s+/g, '-');
                
                return cleanedName.length > 0 ? `${cleanedName}.webp` : 'ai-generated-image.webp';
            }
        } catch (error) {
            console.error('Error generating filename with AI:', error);
        }
        // Fallback filename if AI fails
        return 'converted-image-fallback.webp';
    }

    /**
     * Renders the list of converted results in the UI.
     */
    function renderResults() {
        resultsList.innerHTML = '';
        countDisplay.textContent = conversionResults.length;

        conversionResults.forEach((result) => {
            const item = document.createElement('div');
            item.className = 'flex items-center justify-between p-3 border-b border-gray-200 last:border-b-0';
            
            // Create a temporary Object URL for the blob to be downloadable via anchor tag
            const downloadUrl = URL.createObjectURL(result.blob);

            item.innerHTML = `
                <div class="text-left overflow-hidden">
                    <p class="text-sm text-gray-400 truncate">Original: ${result.originalName}</p>
                    <code class="text-sm font-mono text-gray-800 break-all">${result.filename}</code>
                </div>
                <a href="${downloadUrl}" download="${result.filename}" 
                   class="text-purple-600 hover:text-purple-800 font-semibold text-sm flex-shrink-0 ml-4">
                    Download
                </a>
            `;
            resultsList.appendChild(item);

            // Clean up the temporary URL after the download link is created (optional, but good practice)
            // Note: The URLs created here need to persist until the user decides to download, 
            // but the element is removed on reset, so no need for immediate cleanup.
        });
    }


    /**
     * Converts a list of File objects to WebP Blobs and generates SEO filenames.
     * @param {Array<File>} filesArray - The image files to process.
     */
    async function processFiles(filesArray) {
        // 1. Setup UI for processing
        initialState.classList.add('hidden');
        resultState.classList.add('hidden');
        processingState.classList.remove('hidden');

        conversionResults = []; // Clear previous results
        const totalFiles = filesArray.length;

        for (let i = 0; i < totalFiles; i++) {
            const file = filesArray[i];
            statusText.textContent = `Processing image ${i + 1} of ${totalFiles}: ${file.name}`;
            
            try {
                // 1. Load Image
                const img = new Image();
                const url = URL.createObjectURL(file);

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => reject(new Error(`Failed to load: ${file.name}`));
                    img.src = url;
                });
                URL.revokeObjectURL(url); // Clean up load URL immediately

                // 2. Convert to WebP Blob (using canvas)
                statusText.textContent = `Converting image ${i + 1} of ${totalFiles} to WebP...`;
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);

                const convertedBlob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/webp', 0.60);
                });

                if (!convertedBlob) {
                    throw new Error(`Failed to convert ${file.name} to WebP.`);
                }

                // 3. Generate SEO Filename
                statusText.textContent = `Generating AI filename for ${file.name}...`;
                const base64Image = await blobToBase64(file);
                const seoFilename = await generateSeoFilename(base64Image, file.type);
                
                conversionResults.push({
                    blob: convertedBlob,
                    filename: seoFilename,
                    originalName: file.name
                });

            } catch (error) {
                console.error(`Skipping file ${file.name} due to error:`, error.message);
                // Continue to the next file if one fails
            }
        }

        // 4. Update UI for Result
        if (conversionResults.length > 0) {
            renderResults();
            processingState.classList.add('hidden');
            resultState.classList.remove('hidden');
        } else {
            showError("Conversion failed for all selected files, or no valid images were found.");
            resetApp();
        }
    }


    // --- Event Handlers & Initialization ---

    function handleFileSelection(files) {
        // Filter the FileList for images and convert to a true Array
        const imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
        
        if (imageFiles.length > 0) {
            processFiles(imageFiles); 
        } else if (files && files.length > 0) {
            showError("Invalid file type. Please select supported image file(s) (JPG, PNG, GIF, BMP).");
        }
    }

    // Custom Error Message Box (since alert() is forbidden)
    function showError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        errorDiv.innerHTML = `
            <div class="bg-white p-6 rounded-lg shadow-2xl max-w-sm mx-4 text-center">
                <p class="text-xl font-bold text-red-600 mb-4">Operation Failed</p>
                <p class="text-gray-700 mb-6">${message}</p>
                <button id="close-error-btn" class="purple-gradient-btn text-white font-bold py-2 px-6 rounded-full">
                    Close
                </button>
            </div>
        `;
        document.body.appendChild(errorDiv);

        document.getElementById('close-error-btn').onclick = () => {
            document.body.removeChild(errorDiv);
        };
    }

    // Drag and Drop Listeners
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        // Only allow dragover effect if not already processing
        if (processingState.classList.contains('hidden')) {
            dropZone.classList.add('dragover');
        }
    });

    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        if (processingState.classList.contains('hidden')) { // Only process if not currently processing
            handleFileSelection(e.dataTransfer.files);
        }
    });

    // File Input and Button Listeners
    selectImageBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => handleFileSelection(e.target.files));

    // Download Listener - Updated to trigger sequential downloads for all files
    downloadBtn.addEventListener('click', () => {
        if (conversionResults.length === 0) {
            showError("No converted images available for download.");
            return;
        }

        // Trigger sequential downloads for each result
        conversionResults.forEach((result, index) => {
            // Use a slight delay between downloads to prevent browser blocking/warnings
            setTimeout(() => {
                const a = document.createElement('a');
                const downloadUrl = URL.createObjectURL(result.blob);
                a.href = downloadUrl;
                a.download = result.filename; 
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                // It's safe to revoke the URL immediately after the click has been registered
                URL.revokeObjectURL(downloadUrl);
            }, index * 200); // 200ms delay per file
        });
    });

    // Reset Listener
    function resetApp() {
        // Clear previous data
        conversionResults = [];
        fileInput.value = ''; // Reset file input
        resultsList.innerHTML = ''; // Clear the list UI

        // Reset UI state
        processingState.classList.add('hidden');
        resultState.classList.add('hidden');
        initialState.classList.remove('hidden');
        dropZone.classList.remove('dragover');
    }
    resetBtn.addEventListener('click', resetApp);

    // Initial setup
    resetApp();
</script>
</body>
</html>

