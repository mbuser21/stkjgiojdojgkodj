<!--
WebP Converter with AI-Powered SEO Filenames
This application converts various image formats (PNG, JPG, etc.) to WebP format
and uses the Gemini API to generate an SEO-friendly filename based on the image content.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebP Converter</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the purple gradient background and Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f0f4f8 0%, #e0e8f0 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* Style for the dashed drop zone border and purple accent */
        .drop-zone {
            border: 2px dashed #9333ea; /* Purple color */
            transition: all 0.3s ease;
        }
        .drop-zone.dragover {
            background-color: #f3e8ff; /* Light purple background on drag over */
            border-color: #7e22ce;
        }
        /* Custom purple gradient for the button */
        .purple-gradient-btn {
            background-image: linear-gradient(to right, #9333ea 0%, #7e22ce 100%);
            transition: all 0.3s ease;
        }
        .purple-gradient-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        /* Hide the hidden canvas but keep it in the DOM for conversion */
        #conversion-canvas {
            position: absolute;
            left: -9999px;
            top: -9999px;
        }
    </style>
</head>
<body class="p-4">

    <div id="app" class="w-full max-w-2xl mx-auto text-center p-6 sm:p-10 bg-white shadow-2xl rounded-xl">

        <!-- Header with Settings Button -->
        <div class="mb-8 relative">
            <button id="open-settings-btn" class="absolute top-0 right-0 p-2 text-gray-400 hover:text-purple-600 transition-colors" title="API Settings">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
            </button>
            <div class="mx-auto w-12 h-12 bg-purple-100 rounded-xl flex items-center justify-center mb-4">
                <!-- Icon: Gallery/Image Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-purple-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 18m-4-10h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
            </div>
            <h1 class="text-4xl font-extrabold text-gray-800 mb-2">WebP Converter</h1>
            <p class="text-gray-500">Transform multiple images to WebP with AI-powered SEO filenames.</p>
        </div>

        <!-- Conversion Area / Drop Zone -->
        <div id="drop-zone" class="drop-zone p-8 rounded-xl bg-white shadow-lg flex flex-col items-center justify-center transition-shadow">

            <!-- Hidden file input for selection - ADDED 'multiple' -->
            <input type="file" id="file-input" accept="image/*" class="hidden" multiple>

            <!-- Initial State -->
            <div id="initial-state" class="w-full">
                <div class="mx-auto w-16 h-16 bg-purple-50 rounded-full flex items-center justify-center mb-4">
                    <!-- Upload Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-purple-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                    </svg>
                </div>
                <p class="text-lg font-semibold text-gray-700 mb-2">Drop your images here</p>
                <p class="text-gray-500 mb-6">or click to browse for a batch of files</p>

                <button id="select-image-btn" class="purple-gradient-btn text-white font-bold py-3 px-8 rounded-full shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-purple-300">
                    Select Images
                </button>
                <p class="text-sm text-gray-400 mt-4">Supports JPG, PNG, GIF, BMP, and more</p>
            </div>

            <!-- Conversion Status & Loading State -->
            <div id="processing-state" class="hidden w-full p-4">
                <div id="loading-spinner" class="animate-spin h-10 w-10 border-4 border-purple-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                <!-- Status text will dynamically update with the current file number -->
                <p id="status-text" class="text-lg font-semibold text-purple-600">Processing files...</p>
            </div>

            <!-- Result State - MODIFIED for list view -->
            <div id="result-state" class="hidden w-full p-4">
                <p class="text-lg font-semibold text-green-600 mb-2">Conversion Complete!</p>
                <p class="text-gray-600 mb-4">Successfully converted <span id="count-display" class="font-bold text-purple-600">0</span> images:</p>
                
                <!-- Container for the list of converted files -->
                <div id="results-list" class="space-y-4 max-h-80 overflow-y-auto p-4 bg-gray-50 border border-gray-200 rounded-lg mb-6 text-left">
                    <!-- Results rendered here by JS -->
                </div>
                
                <!-- Download button updated to download all -->
                <button id="download-btn" class="purple-gradient-btn text-white font-bold py-3 px-8 rounded-full shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-purple-300">
                    Download All (.webp)
                </button>
                <button id="reset-btn" class="text-gray-600 bg-white border border-gray-300 font-bold py-3 px-8 rounded-full ml-4 hover:bg-gray-50 focus:outline-none">
                    Convert Another Batch
                </button>
            </div>

        </div>

        <!-- Footer Note -->
        <p class="text-xs text-gray-400 mt-6">
            All processing happens in your browser. Your images never leave your device.
        </p>
        <p class="text-xs text-gray-400 mt-2">
            AI renaming uses the Gemini API.
        </p>

    </div>

    <!-- Hidden Canvas -->
    <canvas id="conversion-canvas"></canvas>

    <!-- Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden transition-opacity duration-300">
        <div class="bg-white p-8 rounded-2xl shadow-2xl max-w-md w-full mx-4 transform transition-all scale-100">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-2xl font-bold text-gray-800">API Settings</h3>
                <button id="close-settings-x" class="text-gray-400 hover:text-gray-600">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            
            <p class="text-gray-600 mb-4 text-sm">
                Enter your Google Gemini API Key. The key is stored securely in your browser's local storage and is never sent to our servers.
            </p>

            <div class="mb-6">
                <label for="api-key-input" class="block text-sm font-medium text-gray-700 mb-2">Gemini API Key</label>
                <input type="password" id="api-key-input" placeholder="AIzaSy..." 
                    class="w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-purple-500 focus:border-purple-500 outline-none transition-all"
                >
                <p class="text-xs text-gray-400 mt-2">
                    Don't have one? <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-purple-600 hover:underline">Get an API key here</a>.
                </p>
            </div>

            <div class="flex justify-end space-x-3">
                <button id="cancel-settings-btn" class="px-6 py-2 rounded-lg text-gray-600 font-medium hover:bg-gray-100 transition-colors">
                    Cancel
                </button>
                <button id="save-settings-btn" class="purple-gradient-btn text-white font-bold py-2 px-6 rounded-lg shadow-md hover:shadow-lg">
                    Save Key
                </button>
            </div>
        </div>
    </div>


<script type="module">
    // --- DOM Elements ---
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const selectImageBtn = document.getElementById('select-image-btn');
    const downloadBtn = document.getElementById('download-btn');
    const resetBtn = document.getElementById('reset-btn');
    const canvas = document.getElementById('conversion-canvas');
    const ctx = canvas.getContext('2d');
    
    // Settings Elements
    const settingsModal = document.getElementById('settings-modal');
    const openSettingsBtn = document.getElementById('open-settings-btn');
    const closeSettingsX = document.getElementById('close-settings-x');
    const cancelSettingsBtn = document.getElementById('cancel-settings-btn');
    const saveSettingsBtn = document.getElementById('save-settings-btn');
    const apiKeyInput = document.getElementById('api-key-input');

    const initialState = document.getElementById('initial-state');
    const processingState = document.getElementById('processing-state');
    const resultState = document.getElementById('result-state');
    const statusText = document.getElementById('status-text');
    
    // NEW DOM elements for batch processing
    const resultsList = document.getElementById('results-list');
    const countDisplay = document.getElementById('count-display');

    // Replaced single file state with an array of results
    let conversionResults = []; // [{ blob: Blob, filename: string, originalName: string }]


    // --- Utility Functions ---

    function getApiKey() {
        return localStorage.getItem('gemini_api_key');
    }

    function setApiKey(key) {
        if (!key || key.trim() === '') {
            localStorage.removeItem('gemini_api_key');
            return;
        }
        localStorage.setItem('gemini_api_key', key.trim());
    }

    function toggleSettingsModal(show) {
        if (show) {
            settingsModal.classList.remove('hidden');
            apiKeyInput.value = getApiKey() || '';
        } else {
            settingsModal.classList.add('hidden');
        }
    }

    /**
     * Converts a File object or Blob into a Base64 string for API submission.
     * @param {Blob | File} blob - The image blob/file.
     * @returns {Promise<string>} Base64 data string.
     */
    function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                // Remove the data URL prefix (e.g., "data:image/png;base64,")
                const base64Data = reader.result.split(',')[1];
                resolve(base64Data);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }

    /**
     * Exponential Backoff Retry mechanism for fetch.
     * @param {Function} apiCall - The function that returns the fetch Promise.
     * @param {number} maxRetries - Maximum number of retries.
     * @returns {Promise<Response>} The final successful Response object.
     */
    async function fetchWithRetry(apiCall, maxRetries = 5) {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await apiCall();
                if (response.ok) {
                    return response;
                }
                // Handle rate limiting or server errors, only retry on 429 or 5xx
                if (response.status === 429 || response.status >= 500) {
                    console.warn(`Attempt ${attempt} failed with status ${response.status}. Retrying...`);
                } else {
                    // Non-retryable error
                    throw new Error(`API call failed with status ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error(`Attempt ${attempt} failed with network error:`, error);
                // Non-retryable error if not a network issue
                if (attempt === maxRetries) {
                     throw error;
                }
            }

            // Exponential backoff wait: 2^attempt * 200ms
            const delay = Math.pow(2, attempt) * 200;
            await new Promise(resolve => setTimeout(resolve, delay));
        }
        throw new Error('API call failed after maximum retries.');
    }


    // --- Core Logic ---

    /**
     * Calls Gemini API to generate an SEO-friendly filename.
     * @param {string} base64Image - Base64 data of the image.
     * @param {string} mimeType - MIME type of the image.
     * @returns {Promise<string>} SEO-friendly filename (e.g., "beautiful-sunset.webp").
     */
    async function generateSeoFilename(base64Image, mimeType) {
        const apiKey = getApiKey();
        if (!apiKey) {
            throw new Error("API Key is missing. Please check your settings.");
        }
        
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

        // System prompt is highly specific to ensure clean output
        const systemPrompt = "You are a specialist in search engine optimization. Your task is to analyze the image and generate the best filename for it. The filename must be: 1. All lowercase. 2. Hyphen-separated. 3. Concise (2 to 5 descriptive words). 4. Must end with the file extension '.webp'. Output ONLY the filename, nothing else.";
        const userQuery = "Generate the SEO filename for this image.";

        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [
                        { text: userQuery },
                        {
                            inlineData: {
                                mimeType: mimeType,
                                data: base64Image
                            }
                        }
                    ]
                }
            ],
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            }
        };

        const apiCall = () => fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        try {
            const response = await fetchWithRetry(apiCall);
            const result = await response.json();
            
            const generatedText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (generatedText) {
                // Clean and normalize the output from the model
                let cleanedName = generatedText.trim().toLowerCase();
                // Remove any surrounding quotes or backticks if the model added them
                cleanedName = cleanedName.replace(/^['"`]|['"`]$/g, '');
                // Replace any non-alphanumeric/non-dot characters (excluding hyphens) with hyphens
                cleanedName = cleanedName.replace(/[^a-z0-9.]+/g, '-');
                // Ensure it ends with .webp, remove it first if it exists, then append
                cleanedName = cleanedName.replace(/\.webp$/, '');
                cleanedName = cleanedName.replace(/^-|-$/g, ' '); // Remove leading/trailing hyphens before cleaning up spaces
                cleanedName = cleanedName.trim().replace(/\s+/g, '-');
                
                return cleanedName.length > 0 ? `${cleanedName}.webp` : 'ai-generated-image.webp';
            }
        } catch (error) {
            console.error('Error generating filename with AI:', error);
        }
        // Fallback filename if AI fails
        return 'converted-image-fallback.webp';
    }

    /**
     * Renders the list of converted results in the UI.
     */
    function renderResults() {
        resultsList.innerHTML = '';
        countDisplay.textContent = conversionResults.length;

        conversionResults.forEach((result) => {
            const item = document.createElement('div');
            item.className = 'flex items-center justify-between p-3 border-b border-gray-200 last:border-b-0';
            
            // Create a temporary Object URL for the blob to be downloadable via anchor tag
            const downloadUrl = URL.createObjectURL(result.blob);

            item.innerHTML = `
                <div class="text-left overflow-hidden">
                    <p class="text-sm text-gray-400 truncate">Original: ${result.originalName}</p>
                    <code class="text-sm font-mono text-gray-800 break-all">${result.filename}</code>
                </div>
                <a href="${downloadUrl}" download="${result.filename}" 
                   class="text-purple-600 hover:text-purple-800 font-semibold text-sm flex-shrink-0 ml-4">
                    Download
                </a>
            `;
            resultsList.appendChild(item);

            // Clean up the temporary URL after the download link is created (optional, but good practice)
            // Note: The URLs created here need to persist until the user decides to download, 
            // but the element is removed on reset, so no need for immediate cleanup.
        });
    }


    /**
     * Converts a list of File objects to WebP Blobs and generates SEO filenames.
     * @param {Array<File>} filesArray - The image files to process.
     */
    async function processFiles(filesArray) {
        // 1. Setup UI for processing
        initialState.classList.add('hidden');
        resultState.classList.add('hidden');
        processingState.classList.remove('hidden');

        conversionResults = []; // Clear previous results
        const totalFiles = filesArray.length;

        for (let i = 0; i < totalFiles; i++) {
            const file = filesArray[i];
            statusText.textContent = `Processing image ${i + 1} of ${totalFiles}: ${file.name}`;
            
            try {
                // 1. Load Image
                const img = new Image();
                const url = URL.createObjectURL(file);

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => reject(new Error(`Failed to load: ${file.name}`));
                    img.src = url;
                });
                URL.revokeObjectURL(url); // Clean up load URL immediately

                // 2. Convert to WebP Blob (using canvas)
                statusText.textContent = `Converting image ${i + 1} of ${totalFiles} to WebP...`;
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);

                const convertedBlob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/webp', 0.60);
                });

                if (!convertedBlob) {
                    throw new Error(`Failed to convert ${file.name} to WebP.`);
                }

                // 3. Generate SEO Filename
                statusText.textContent = `Generating AI filename for ${file.name}...`;
                const base64Image = await blobToBase64(file);
                const seoFilename = await generateSeoFilename(base64Image, file.type);
                
                conversionResults.push({
                    blob: convertedBlob,
                    filename: seoFilename,
                    originalName: file.name
                });

            } catch (error) {
                console.error(`Skipping file ${file.name} due to error:`, error.message);
                // Continue to the next file if one fails
            }
        }

        // 4. Update UI for Result
        if (conversionResults.length > 0) {
            renderResults();
            processingState.classList.add('hidden');
            resultState.classList.remove('hidden');
        } else {
            showError("Conversion failed for all selected files, or no valid images were found.");
            resetApp();
        }
    }


    // --- Event Handlers & Initialization ---

    function handleFileSelection(files) {
        // Filter the FileList for images and convert to a true Array
        const imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
        
        if (imageFiles.length > 0) {
            processFiles(imageFiles); 
        } else if (files && files.length > 0) {
            showError("Invalid file type. Please select supported image file(s) (JPG, PNG, GIF, BMP).");
        }
    }

    // Custom Error Message Box (since alert() is forbidden)
    function showError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        errorDiv.innerHTML = `
            <div class="bg-white p-6 rounded-lg shadow-2xl max-w-sm mx-4 text-center">
                <p class="text-xl font-bold text-red-600 mb-4">Operation Failed</p>
                <p class="text-gray-700 mb-6">${message}</p>
                <button id="close-error-btn" class="purple-gradient-btn text-white font-bold py-2 px-6 rounded-full">
                    Close
                </button>
            </div>
        `;
        document.body.appendChild(errorDiv);

        document.getElementById('close-error-btn').onclick = () => {
            document.body.removeChild(errorDiv);
        };
    }

    // Drag and Drop Listeners
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        // Only allow dragover effect if not already processing
        if (processingState.classList.contains('hidden')) {
            dropZone.classList.add('dragover');
        }
    });

    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        if (processingState.classList.contains('hidden')) { // Only process if not currently processing
            handleFileSelection(e.dataTransfer.files);
        }
    });

    // File Input and Button Listeners
    selectImageBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => handleFileSelection(e.target.files));

    // Download Listener - Updated to trigger sequential downloads for all files
    downloadBtn.addEventListener('click', () => {
        if (conversionResults.length === 0) {
            showError("No converted images available for download.");
            return;
        }

        // Trigger sequential downloads for each result
        conversionResults.forEach((result, index) => {
            // Use a slight delay between downloads to prevent browser blocking/warnings
            setTimeout(() => {
                const a = document.createElement('a');
                const downloadUrl = URL.createObjectURL(result.blob);
                a.href = downloadUrl;
                a.download = result.filename; 
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                // It's safe to revoke the URL immediately after the click has been registered
                URL.revokeObjectURL(downloadUrl);
            }, index * 200); // 200ms delay per file
        });
    });

    // Reset Listener
    function resetApp() {
        // Clear previous data
        conversionResults = [];
        fileInput.value = ''; // Reset file input
        resultsList.innerHTML = ''; // Clear the list UI

        // Reset UI state
        processingState.classList.add('hidden');
        resultState.classList.add('hidden');
        initialState.classList.remove('hidden');
        dropZone.classList.remove('dragover');
    }
    resetBtn.addEventListener('click', resetApp);

    // Settings Logic
    openSettingsBtn.addEventListener('click', () => toggleSettingsModal(true));
    closeSettingsX.addEventListener('click', () => toggleSettingsModal(false));
    cancelSettingsBtn.addEventListener('click', () => toggleSettingsModal(false));
    
    saveSettingsBtn.addEventListener('click', () => {
        const key = apiKeyInput.value;
        if (key.trim().length === 0) {
            alert('Please enter a valid API key.');
            return;
        }
        setApiKey(key);
        toggleSettingsModal(false);
        // Optionally reload or just let the user continue
        // Check if we are in a "processing" blocked state? No, usually fine.
    });

    // Initial API Key Check
    (function checkApiKey() {
        const key = getApiKey();
        if (!key) {
            // Show modal immediately if no key
            // Use setTimeout to ensure DOM is fully ready/rendered
            setTimeout(() => toggleSettingsModal(true), 500);
        }
    })();

    // Initial setup
    resetApp();
</script>
</body>
</html>


